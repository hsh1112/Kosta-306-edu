네, 요청하신 내용을 바탕으로 발표 자료나 기술 문서에 바로 활용할 수 있도록 **깔끔한 마크다운(Markdown) 형식**으로 정리해 드립니다.

원문에서 단점으로 언급되었던 부분 중 **'OCP를 지키지 않았을 때의 문제점'**과 **'OCP를 적용했을 때의 트레이드오프(비용)'**를 구분하여 더 정확하게 보완했습니다.

---

# [발표 자료] SOLID 원칙과 OCP(개방-폐쇄 원칙) 심층 이해

## 1. SOLID 원칙 개요

SOLID는 클린 코드로 유명한 로버트 마틴이 제시한 **‘좋은 객체 지향 설계’**의 지침서입니다. 이 원칙들은 **“높은 응집도와 낮은 결합도(High Cohesion - Loose Coupling)”**라는 대원칙을 구체화한 것입니다.

### 💡 핵심 목표

* 모듈 간 간섭을 줄여, **하나를 고칠 때 열 개가 부서지는 현상(사이드 이펙트)**을 방지합니다.
* 코드의 확장성과 유지보수성을 높여 전체적인 개발 생산성을 향상시킵니다.

### 🛠 5대 원칙 요약

* **SRP (Single Responsibility):** 한 클래스는 하나의 책임만 가짐.
* **OCP (Open-Closed):** 확장에는 열려 있고, 변경에는 닫혀 있음.
* **LSP (Liskov Substitution):** 하위 타입은 상위 타입을 온전하게 대체 가능해야 함.
* **ISP (Interface Segregation):** 사용하지 않는 인터페이스에 의존하지 않도록 분리함.
* **DIP (Dependency Inversion):** 구현체가 아닌 추상화(인터페이스)에 의존함.

---

## 2. OCP (Open-Closed Principle) 상세 설명

> **"소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다."**

* **확장에는 열려 있다 (Open):** 새로운 요구사항이 생기면 코드를 추가하여 기능을 유연하게 확장할 수 있음.
* **변경에는 닫혀 있다 (Closed):** 기능을 확장할 때, 기존의 작동하던 코드를 직접 수정하지 않음.

---

## 3. 코드 실무 사례: 결제 시스템

### ❌ Bad Practice (OCP 위반)

신규 결제 수단이 추가될 때마다 기존 서비스 코드를 직접 수정해야 하며, 이는 버그의 원인이 됩니다.

```java
class PaymentService {
    public void pay(String type) {
        if (type.equals("card")) {
            new CardPayment().process();
        } else if (type.equals("naver")) {
            new NaverPay().process();
        } 
        // ⚠️ 문제: 애플페이가 추가되면 여기 if-else 로직을 또 수정해야 함 (Closed 위반)
    }
}

```

### ✅ Best Practice (OCP 준수)

인터페이스를 통해 역할을 추상화하여, 기존 코드 수정 없이 클래스 추가만으로 기능을 확장합니다.

```java
// 1. 역할 정의 (추상화)
interface Payment {
    void process();
}

// 2. 구현체 확장 (Open: 기존 코드를 건드리지 않고 클래스만 추가)
class CardPayment implements Payment {
    public void process() { System.out.println("카드 결제 진행"); }
}

class KakaoPay implements Payment {
    public void process() { System.out.println("카카오페이 결제 진행"); }
}

// 3. 서비스 로직 (Closed: 인터페이스에 의존하여 변경에 영향받지 않음)
class PaymentService {
    public void pay(Payment payment) {
        // 어떤 결제 수단이 들어와도 이 코드는 수정할 필요가 없음
        payment.process();
    }
}

```

---

## 4. OCP의 장단점 및 주의사항

### 👍 장점

1. **유지보수 비용 감소:** 기존 코드의 안정성을 보장함.
2. **코드 안정성:** 사이드 이펙트(Side Effect)가 줄어들어 테스트 범위가 명확해짐.
3. **협업 효율:** 모듈이 분리되어 여러 개발자가 동시에 다른 기능을 개발하기 용이함.

### ⚠️ 고려해야 할 점 (Trade-off)

1. **설계 복잡도 증가:** 인터페이스와 추상 클래스가 늘어나 코드 구조가 복잡해질 수 있음.
2. **오버 엔지니어링 주의:** 변화 가능성이 낮은 곳까지 무리하게 추상화를 적용하면 가독성이 떨어짐.

---

## 5. SOLID 원칙의 유기적 흐름

OCP는 단독으로 완성되지 않으며, 다른 원칙들과 조화를 이룰 때 완성됩니다.

* **SRP로 책임 분리** → 확장 지점이 명확해짐.
* **DIP로 추상화 의존** → OCP를 실현하는 구체적인 수단.
* **LSP로 다형성 보장** → 하위 클래스가 부모의 역할을 충실히 수행하여 안전한 교체 가능.

**"SRP로 나누고, DIP로 연결하며, LSP로 다형성을 확보하면 최종적으로 OCP가 달성된다."**

---

## 6. 결론

결국 좋은 객체지향 설계란 **“지금 당장의 완벽함이 아니라, 미래의 변경을 대비하는 설계”**입니다.
변하는 것과 변하지 않는 것을 명확히 구분하고, 변화가 예상되는 지점에 전략적으로 OCP를 적용하는 것이 실력 있는 개발자의 핵심 역량입니다.

---
